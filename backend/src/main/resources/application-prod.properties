# Server Configuration
server.port=8080
spring.application.name=banco-ai

# Database Configuration (PostgreSQL para produção)
# ATENÇÃO: Configure estas variáveis de ambiente no servidor
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5432/banco_ai}
spring.datasource.username=${DATABASE_USER:postgres}
spring.datasource.password=${DATABASE_PASSWORD:}
spring.datasource.driver-class-name=org.postgresql.Driver

# H2 Console desabilitado em produção
spring.h2.console.enabled=false

# JPA Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=false

# Performance - Pool de Conexões HikariCP
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.leak-detection-threshold=60000

# Performance - JPA/Hibernate
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
spring.jpa.properties.hibernate.generate_statistics=false

# Performance - Query Cache (opcional, pode melhorar performance)
spring.jpa.properties.hibernate.cache.use_second_level_cache=false
spring.jpa.properties.hibernate.cache.use_query_cache=false

# Performance - Connection Pool Monitoring
spring.datasource.hikari.register-mbeans=true

# File Upload Configuration
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# CORS Configuration - Configure com o domínio do seu servidor
spring.web.cors.allowed-origins=${FRONTEND_URL:http://localhost:3000}
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true

# JWT Configuration - Use uma chave secreta forte em produção!
jwt.secret=${JWT_SECRET:bancoAiSecretKey2024SuperSecureKeyForJWTTokenGenerationChangeThisInProduction}
jwt.expiration=86400000

# File Storage
file.upload-dir=${UPLOAD_DIR:uploads/carros}

# Email Configuration - Configure com suas credenciais
# Opção 1: Gmail SMTP (requer senha de app - pode expirar)
# Opção 2: SendGrid (recomendado para produção - não expira)
# Opção 3: Outro servidor SMTP

# Para Gmail:
# spring.mail.host=smtp.gmail.com
# spring.mail.port=587
# spring.mail.username=seu_email@gmail.com
# spring.mail.password=senha_de_app_gerada (16 caracteres, sem espaços)

# Para SendGrid (recomendado):
# spring.mail.host=smtp.sendgrid.net
# spring.mail.port=587
# spring.mail.username=apikey
# spring.mail.password=SG.sua_api_key_aqui

# Configuração atual (via variáveis de ambiente)
spring.mail.host=${MAIL_HOST:smtp.gmail.com}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:}
spring.mail.password=${MAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# Email From Address (deve ser um email verificado no SendGrid)
# Para SendGrid: verifique o email em Settings → Sender Authentication → Single Sender Verification
app.mail.from=${MAIL_FROM:quickAI.automation@gmail.com}

# Habilitar/desabilitar envio de email (útil para testes)
app.email.enabled=${EMAIL_ENABLED:true}

# Frontend URL
app.frontend.url=${FRONTEND_URL:http://localhost:3000}

# Forçar HTTPS nas URLs das imagens da API pública
app.force-https=true

# URL base do servidor (opcional, se não configurado será detectada automaticamente)
# app.base-url=https://bancoai.com.br

